<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REACT Ground Control Station - Satellite Map</title>
    
    <!-- Leaflet CSS (local) -->
    <link rel="stylesheet" href="/static/leaflet/leaflet.css" />
    
    <!-- Leaflet.pm (geoman) CSS for polygon editing -->
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
            pointer-events: auto; /* Ensure map can receive mouse events */
            touch-action: none; /* For better touch handling in QtWebEngine */
        }
        
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px; /* Position at top right */
            z-index: 1000;
            display: flex;
            flex-direction: column; /* Vertical layout */
            align-items: flex-start;
            gap: 5px; /* Small gap between elements */
        }
        
        .map-controls select, .map-controls button {
            margin: 0;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .map-controls select:hover, .map-controls button:hover {
            background: #f5f5f5;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        
        /* UAV Marker Styles */
        .uav-marker {
            transition: transform 0.3s ease;
        }
        
        .uav-marker:hover {
            transform: scale(1.2);
        }
        
        /* Home Marker Animation */
        .home-marker {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Context Menu Styles */
        #contextMenu {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 10000;
            padding: 5px 0;
            min-width: 150px;
        }
        
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
        }
        
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }
        
        .context-menu-separator {
            height: 1px;
            background-color: #e0e0e0;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="map-controls">
        <button onclick="fitAllUAVs()">Fit All UAVs</button>
        <select id="mapTypeSelect">
            <option value="osm" selected>Street Map</option>
            <option value="satellite">Satellite</option>
            <option value="hybrid">Hybrid</option>
        </select>
        <div id="infoDisplay" style="
            background: rgba(0, 0, 0, 0.4); 
            color: white; 
            padding: 6px 8px; 
            border-radius: 3px; 
            margin-top: 5px;
            text-align: center;
            line-height: 1.2;
        ">
            <div id="zoomDisplay" style="
                font-size: 12px; 
                font-weight: bold;
                margin-bottom: 2px;
            ">Zoom: --</div>
            <div id="latDisplay" style="
                font-size: 11px; 
                font-family: monospace;
                margin-bottom: 1px;
            ">Lat: --</div>
            <div id="lonDisplay" style="
                font-size: 11px; 
                font-family: monospace;
            ">Lon: --</div>
        </div>
    </div>
    
    <!-- Scale bar at bottom right -->
    <div id="scaleBar" style="
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid #333;
        border-radius: 3px;
        padding: 5px 8px;
        font-size: 11px;
        font-weight: bold;
        color: #333;
        z-index: 1000;
    ">
        <div id="scaleBarLine" style="
            height: 3px;
            background: #333;
            margin-bottom: 2px;
            width: 100px;
        "></div>
        <div id="scaleBarText">-- km</div>
    </div>
    
    <!-- Context Menu -->
    <div id="contextMenu">
        <div class="context-menu-item" onclick="setHomeAtContextPosition()">üìç Set GCS Home Here</div>
    </div>

    <div id="map"></div>    <!-- Qt WebChannel Script (conditionally loaded) -->
    <script>
        // Try to load Qt WebChannel if available
        try {
            const script = document.createElement('script');
            script.src = 'qrc:///qtwebchannel/qwebchannel.js';
            script.onerror = () => console.log('Qt WebChannel not available');
            document.head.appendChild(script);
        } catch (e) {
            console.log('Qt WebChannel not available');
        }
    </script>
    
    <!-- Leaflet JavaScript (local) -->
    <script src="/static/leaflet/leaflet.js"></script>
    
    <!-- Leaflet.pm (geoman) JavaScript for polygon editing -->
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>
    
    <script>
        console.log('REACT satellite_map.html JavaScript loaded');
        console.log('Starting REACT satellite map...');
        
        let map;
        let uavMarkers = {};
        let qtChannel = null;
        let qtBridge = null;
        
        // Polygon drawing state (declare early for event handlers)
        let polygonDrawing = false;
        let currentPolygonId = null;  // Track which polygon is being drawn
        let polygonPoints = [];
        let polygonMarkers = [];
        let polygonLines = [];
        let drawnPolygons = {};  // Changed from single to map of polygons keyed by ID
        let tempLine = null;
        
        // Camera configuration (from config.yaml)
        let cameraConfig = {
            hfov: 73.4,           // Horizontal field of view (degrees)
            vfov: 52.0,           // Vertical field of view (degrees)
            image_width: 6000,    // Image width in pixels
            image_height: 4000    // Image height in pixels
        };
        
        // Function to set camera configuration from QML (called when map loads)
        function setCameraConfig(config) {
            cameraConfig = config;
            console.log('Camera config updated from config.yaml:', cameraConfig);
            
            // Update all existing polygon popups with new GSD calculations
            Object.keys(drawnPolygons).forEach(function(polygonId) {
                var polygon = drawnPolygons[polygonId];
                if (polygon) {
                    updatePolygonPopup(polygon, parseInt(polygonId));
                }
            });
        }
        
        // Store altitude per polygon for GSD calculation
        let polygonAltitudes = {};  // Maps polygon ID to altitude
        
        // Map layer definitions - now using same origin!
        let mapLayers = {};
        
        function initMapLayers() {
            if (typeof L === 'undefined') {
                console.error('Leaflet not available');
                return false;
            }
            
            // Load config from backend
            const currentOrigin = window.location.origin;
            return fetch(currentOrigin + '/api/config')
                .then(response => response.json())
                .then(config => {
                    const streetTransparency = config.map?.street_transparency || 0.5;
                    
                    // Same-origin tiles (cache-first for offline)
                    mapLayers = {
                        osm: L.tileLayer(currentOrigin + '/tiles/openstreetmap/{z}/{x}/{y}.png', {
                            maxZoom: 22,
                            attribution: '¬© OpenStreetMap contributors',
                            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='
                        }),
                        
                        satellite: L.tileLayer(currentOrigin + '/tiles/satellite/{z}/{x}/{y}.png', {
                            maxZoom: 22,
                            attribution: 'Google Satellite via Local Cache',
                            updateWhenIdle: false,
                            updateWhenZooming: true,
                            keepBuffer: 2,
                            errorTileUrl: currentOrigin + '/blank_tile.png',
                            getTileUrl: function(coords) {
                                const url = currentOrigin + `/tiles/satellite/${coords.z}/${coords.x}/${coords.y}.png`;
                                console.log('Requesting satellite tile:', url);
                                return url;
                            }
                        }),
                        
                        hybrid: L.layerGroup([
                            L.tileLayer(currentOrigin + '/tiles/satellite/{z}/{x}/{y}.png', {
                                maxZoom: 22,
                                attribution: 'Google Satellite via Local Cache',
                                errorTileUrl: currentOrigin + '/blank_tile.png'
                            }),
                            L.tileLayer(currentOrigin + '/tiles/openstreetmap/{z}/{x}/{y}.png', {
                                maxZoom: 22,
                                attribution: '¬© OpenStreetMap contributors',
                                opacity: streetTransparency,
                                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='
                            })
                        ])
                    };
                    
                    return true;
                })
                .catch(error => {
                    console.error('Error loading config:', error);
                    // Fallback without config (offline mode)
                    const currentOrigin = window.location.origin;
                    mapLayers = {
                        osm: L.tileLayer(currentOrigin + '/tiles/openstreetmap/{z}/{x}/{y}.png', {
                            maxZoom: 22,
                            attribution: '¬© OpenStreetMap contributors',
                            errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='
                        }),
                        
                        satellite: L.tileLayer(currentOrigin + '/tiles/satellite/{z}/{x}/{y}.png', {
                            maxZoom: 22,
                            attribution: 'Google Satellite via Local Cache',
                            updateWhenIdle: false,
                            updateWhenZooming: true,
                            keepBuffer: 2,
                            errorTileUrl: currentOrigin + '/blank_tile.png',
                            getTileUrl: function(coords) {
                                const url = currentOrigin + `/tiles/satellite/${coords.z}/${coords.x}/${coords.y}.png`;
                                console.log('Requesting satellite tile:', url);
                                return url;
                            }
                        }),
                        
                        hybrid: L.layerGroup([
                            L.tileLayer(currentOrigin + '/tiles/satellite/{z}/{x}/{y}.png', {
                                maxZoom: 22,
                                attribution: 'Google Satellite via Local Cache',
                                errorTileUrl: currentOrigin + '/blank_tile.png'
                            }),
                            L.tileLayer(currentOrigin + '/tiles/openstreetmap/{z}/{x}/{y}.png', {
                                maxZoom: 22,
                                attribution: '¬© OpenStreetMap contributors',
                                opacity: 0.5,
                                errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=='
                            })
                        ])
                    };
                    return true;
                });
        }
        
        async function initMap() {
            if (typeof L === 'undefined') {
                console.error('Error: Leaflet not loaded');
                return;
            }
            
            console.log('Initializing map...');
            
            try {
                const layersReady = await initMapLayers();
                if (!layersReady) {
                    console.error('Error: Could not initialize layers');
                    return;
                }
            } catch (error) {
                console.error('Error initializing layers:', error);
                return;
            }
            
            // Fetch default home position from server (with offline fallback)
            const currentOrigin = window.location.origin;
            const apiUrl = currentOrigin + '/api/info?t=' + Date.now(); // Cache-busting
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    console.log('API info received:', data);
                    console.log('Default home from API:', data.default_home_position);
                    const homePos = data.default_home_position || {
                        latitude: 40.7128,
                        longitude: -76.006,
                        zoom: 12
                    };
                    console.log('Using home position:', homePos);
                    
                    initMapWithPosition(homePos);
                })
                .catch(error => {
                    console.warn('Failed to get default home position (offline mode?):', error);
                    // Offline fallback to configured position
                    const fallbackPos = {
                        latitude: 40.7128,
                        longitude: -76.006,
                        zoom: 12
                    };
                    console.log('Using offline fallback position:', fallbackPos);
                    initMapWithPosition(fallbackPos);
                });
        }
        
        function initMapWithPosition(homePos) {
            try {
                // Create map centered on configured home position with explicit interaction options
                map = L.map('map', {
                    center: [homePos.latitude, homePos.longitude],
                    zoom: homePos.zoom,
                    dragging: true,
                    touchZoom: true,
                    doubleClickZoom: true,
                    scrollWheelZoom: true,
                    boxZoom: true,
                    keyboard: true,
                    zoomControl: true,
                    attributionControl: true
                });
                
                // Load config to get default layer (with offline fallback)
                const currentOrigin = window.location.origin;
                fetch(currentOrigin + '/api/config')
                    .then(response => response.json())
                    .then(config => {
                        const defaultLayer = config.map?.default_layer || 'satellite';
                        console.log('Config loaded, default layer:', defaultLayer);
                        if (mapLayers[defaultLayer]) {
                            mapLayers[defaultLayer].addTo(map);
                            currentLayer = mapLayers[defaultLayer];
                            console.log('Started with default layer:', defaultLayer);
                        } else {
                            mapLayers.satellite.addTo(map);
                            currentLayer = mapLayers.satellite;
                            console.log('Fallback to satellite layer');
                        }
                    })
                    .catch(error => {
                        console.warn('Could not load config (offline mode?), using satellite layer:', error);
                        // Offline fallback to satellite
                        mapLayers.satellite.addTo(map);
                        currentLayer = mapLayers.satellite;
                        console.log('Offline mode - using satellite layer');
                    });
                
                console.log(`Map initialized at ${homePos.latitude}, ${homePos.longitude} with zoom ${homePos.zoom}`);
                
                // Set up map type selector
                const mapTypeSelect = document.getElementById('mapTypeSelect');
                mapTypeSelect.addEventListener('change', function() {
                    changeMapType(this.value);
                });
                
                // Initialize displays
                updateZoomDisplay();
                updateCoordsDisplay();
                updateScaleBar();
                
                // Test tile loading
                testTileServer();
                
                // Add map event handlers for all displays
                map.on('zoomend', function(e) {
                    updateZoomDisplay();
                    updateScaleBar();
                });
                
                map.on('moveend', function(e) {
                    updateCoordsDisplay();
                    updateScaleBar();
                });
                
                // Add debug logging for map events (commented out to prevent high-frequency console spam)
                // map.on('movestart', function(e) {
                //     console.log('Map move started');
                // });
                
                // map.on('move', function(e) {
                //     console.log('Map is moving, center:', map.getCenter());
                // });
                
                // map.on('moveend', function(e) {
                //     console.log('Map move ended, center:', map.getCenter(), 'zoom:', map.getZoom());
                // });
                
                // map.on('drag', function(e) {
                //     console.log('Map drag event');
                // });
                
                // Add context menu on right-click
                map.on('contextmenu', function(e) {
                    // Handle polygon completion on right-click if in drawing mode
                    if (polygonDrawing && polygonPoints.length >= 3) {
                        e.originalEvent.preventDefault();
                        completePolygon();
                    } else {
                        showContextMenu(e.originalEvent.clientX, e.originalEvent.clientY, e.latlng);
                    }
                });
                
                // Hide context menu on left-click (unless in polygon drawing mode)
                map.on('click', function(e) {
                    if (polygonDrawing) {
                        console.log('Map clicked in polygon mode, adding point at:', e.latlng.lat, e.latlng.lng);
                        addPolygonPoint(e.latlng.lat, e.latlng.lng);
                    } else {
                        hideContextMenu();
                    }
                });
                
                // Map mouse move handler for temporary line preview
                map.on('mousemove', function(e) {
                    if (polygonDrawing && polygonPoints.length > 0) {
                        // Remove old temp line
                        if (tempLine) {
                            map.removeLayer(tempLine);
                        }
                        
                        // Draw temp line from last point to cursor
                        const lastPoint = polygonPoints[polygonPoints.length - 1];
                        tempLine = L.polyline(
                            [[lastPoint.lat, lastPoint.lon], [e.latlng.lat, e.latlng.lng]],
                            {
                                color: '#2196F3',
                                weight: 2,
                                opacity: 0.4,
                                dashArray: '5, 5'
                            }
                        );
                        tempLine.addTo(map);
                    }
                });
            } catch (error) {
                console.error('Map initialization error:', error);
            }
        }
        
        // Context menu handling
        let contextMenuPosition = null;
        
        function showContextMenu(x, y, latlng) {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'block';
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenuPosition = latlng;
        }
        
        function hideContextMenu() {
            const contextMenu = document.getElementById('contextMenu');
            contextMenu.style.display = 'none';
            contextMenuPosition = null;
        }
        
        function setHomeAtContextPosition() {
            if (contextMenuPosition && qtBridge && qtBridge.setGCSHome) {
                console.log('Setting GCS home at:', contextMenuPosition.lat, contextMenuPosition.lng);
                qtBridge.setGCSHome(contextMenuPosition.lat, contextMenuPosition.lng);
                updateGCSHomeMarker(contextMenuPosition.lat, contextMenuPosition.lng);
            }
            hideContextMenu();
        }
        
        // GCS Home marker (blue with 'H')
        let gcsHomeMarker = null;
        function updateGCSHomeMarker(lat, lon) {
            if (!map) return;
            
            if (gcsHomeMarker) {
                map.removeLayer(gcsHomeMarker);
            }
            
            const gcsIcon = L.divIcon({
                html: `
                    <div style="
                        width: 24px; 
                        height: 24px; 
                        background: rgba(30, 144, 255, 0.3); 
                        border: 3px solid #1E90FF; 
                        border-radius: 50%;
                        box-shadow: 0 2px 6px rgba(0,0,0,0.4);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <span style="
                            color: #1E90FF;
                            font-weight: bold;
                            font-size: 14px;
                            font-family: Arial, sans-serif;
                        ">H</span>
                    </div>
                `,
                className: 'gcs-home-marker',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            gcsHomeMarker = L.marker([lat, lon], {icon: gcsIcon});
            gcsHomeMarker.bindPopup(`<strong>GCS Home Position</strong><br/>Ground Control Station<br/>Position: ${lat.toFixed(6)}, ${lon.toFixed(6)}`);
            gcsHomeMarker.addTo(map);
            
            console.log('GCS home marker updated at:', lat, lon);
        }
        
        let currentLayer = null;
        
        function changeMapType(mapType) {
            console.log('Changing map type to:', mapType);
            if (mapLayers[mapType]) {
                if (currentLayer) {
                    map.removeLayer(currentLayer);
                }
                currentLayer = mapLayers[mapType];
                map.addLayer(currentLayer);
                console.log('Map layer changed to:', mapType);
            } else {
                console.error('Map type not found:', mapType);
            }
        }
        
        // Update zoom level display
        function updateZoomDisplay() {
            const zoomDisplay = document.getElementById('zoomDisplay');
            if (map && zoomDisplay) {
                const currentZoom = map.getZoom();
                zoomDisplay.textContent = `Zoom: ${currentZoom}`;
            }
        }
        
        // Update coordinates display
        function updateCoordsDisplay() {
            const latDisplay = document.getElementById('latDisplay');
            const lonDisplay = document.getElementById('lonDisplay');
            if (map && latDisplay && lonDisplay) {
                const center = map.getCenter();
                const lat = center.lat.toFixed(6);
                const lon = center.lng.toFixed(6);
                latDisplay.textContent = `Lat: ${lat}`;
                lonDisplay.textContent = `Lon: ${lon}`;
            }
        }
        
        // Update scale bar
        function updateScaleBar() {
            if (!map) return;
            
            const scaleBarLine = document.getElementById('scaleBarLine');
            const scaleBarText = document.getElementById('scaleBarText');
            
            if (!scaleBarLine || !scaleBarText) return;
            
            // Get current zoom and calculate scale
            const zoom = map.getZoom();
            const center = map.getCenter();
            
            // Calculate meters per pixel at current zoom and latitude
            const earthCircumference = 40075017; // meters
            const metersPerPixelAtEquator = earthCircumference / Math.pow(2, zoom + 8);
            const metersPerPixel = metersPerPixelAtEquator * Math.cos(center.lat * Math.PI / 180);
            
            // Scale bar width in pixels
            const scaleBarWidthPixels = 100;
            const scaleBarWidthMeters = metersPerPixel * scaleBarWidthPixels;
            
            // Choose appropriate scale and unit
            let scaleText;
            let actualWidth;
            
            if (scaleBarWidthMeters > 1000) {
                const km = scaleBarWidthMeters / 1000;
                if (km > 10) {
                    scaleText = `${Math.round(km)} km`;
                    actualWidth = Math.round(km) * 1000 / metersPerPixel;
                } else if (km > 1) {
                    scaleText = `${km.toFixed(1)} km`;
                    actualWidth = parseFloat(km.toFixed(1)) * 1000 / metersPerPixel;
                } else {
                    scaleText = `${Math.round(scaleBarWidthMeters)} m`;
                    actualWidth = Math.round(scaleBarWidthMeters) / metersPerPixel;
                }
            } else {
                if (scaleBarWidthMeters > 100) {
                    scaleText = `${Math.round(scaleBarWidthMeters)} m`;
                    actualWidth = Math.round(scaleBarWidthMeters) / metersPerPixel;
                } else if (scaleBarWidthMeters > 10) {
                    scaleText = `${Math.round(scaleBarWidthMeters)} m`;
                    actualWidth = Math.round(scaleBarWidthMeters) / metersPerPixel;
                } else {
                    scaleText = `${Math.round(scaleBarWidthMeters)} m`;
                    actualWidth = Math.round(scaleBarWidthMeters) / metersPerPixel;
                }
            }
            
            scaleBarLine.style.width = actualWidth + 'px';
            scaleBarText.textContent = scaleText;
        }
        
        function testTileServer() {
            const currentOrigin = window.location.origin;
            
            // Test API endpoint
            fetch(currentOrigin + '/api/info')
                .then(response => response.json())
                .then(data => {
                    console.log('API connected successfully');
                    console.log('API info:', data);
                })
                .catch(error => {
                    console.error('API connection failed: ' + error.message);
                });
                
            // Test tile endpoint
            fetch(currentOrigin + '/tiles/satellite/0/0/0.png')
                .then(response => {
                    if (response.ok) {
                        console.log('Satellite tiles: Available');
                    } else {
                        console.error('Satellite tiles: HTTP ' + response.status);
                    }
                })
                .catch(error => {
                    console.error('Satellite tiles: ' + error.message);
                });
        }
        
        // Center map on UAV
        function centerOnUAV(uavId) {
            if (uavId && uavMarkers[uavId]) {
                const marker = uavMarkers[uavId];
                const pos = marker.getLatLng();
                map.setView([pos.lat, pos.lng], Math.max(map.getZoom(), 16));
                
                // Briefly highlight the UAV
                marker.openPopup();
                setTimeout(() => {
                    marker.closePopup();
                }, 2000);
            }
        }

        function fitAllUAVs() {
            const group = new L.featureGroup(Object.values(uavMarkers));
            if (group.getLayers().length > 0) {
                map.fitBounds(group.getBounds(), {padding: [20, 20]});
            }
        }

        // Center map on specific UAV
        function centerOnUAV(uavId) {
            if (uavMarkers[uavId]) {
                const marker = uavMarkers[uavId];
                const position = marker.getLatLng();
                map.setView([position.lat, position.lng], Math.max(map.getZoom(), 16));
                
                // Briefly highlight the UAV
                marker.openPopup();
                setTimeout(() => {
                    marker.closePopup();
                }, 2000);
            }
        }
        
        // Wait for Leaflet to load, then initialize
        function waitForLeaflet() {
            if (typeof L !== 'undefined') {
                console.log('Leaflet loaded, initializing map...');
                initMap();
            } else {
                console.log('Waiting for Leaflet to load...');
                setTimeout(waitForLeaflet, 100);
            }
        }
        
        // Start when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, waiting for Leaflet...');
            console.log('Loading Leaflet...');
            waitForLeaflet();
            
            // Hide context menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#contextMenu')) {
                    hideContextMenu();
                }
            });
        });
        
        // Qt WebChannel integration (if available)
        setTimeout(() => {
            if (typeof QWebChannel !== 'undefined') {
                console.log('QWebChannel available, setting up Qt bridge...');
                initQtWebChannel();
            } else {
                console.log('QWebChannel not available - using test UAV markers');
                addTestUAVMarkers();
            }
        }, 1000);

        // Qt WebChannel setup
        function initQtWebChannel() {
            try {
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    console.log('Qt WebChannel initialized');
                    qtChannel = channel;
                    qtBridge = channel.objects.mapBridge;
                    
                    if (qtBridge) {
                        console.log('Qt mapBridge connected');
                        console.log('Available qtBridge properties:', Object.keys(qtBridge));
                        
                        // Connect to UAV position updates
                        if (qtBridge.uavPositionChanged) {
                            qtBridge.uavPositionChanged.connect(function(uavId, lat, lon, heading, mode, armed) {
                                // console.log('UAV position update:', uavId, lat, lon, heading, mode, armed);  // Commented to reduce log spam
                                updateUAVMarker(uavId, lat, lon, heading, mode, armed);
                            });
                        }
                        
                        // REMOVED: homePositionChanged - now using gcsHomePositionChanged for GCS home
                        // and launchLocationChanged for individual UAV launch positions
                        
                        // Connect to launch location updates
                        if (qtBridge.launchLocationChanged) {
                            qtBridge.launchLocationChanged.connect(function(uavId, lat, lon) {
                                console.log('Launch location update:', uavId, lat, lon);
                                updateLaunchLocationMarker(uavId, lat, lon);
                            });
                        } else {
                            console.error('launchLocationChanged signal not available on qtBridge');
                        }
                        
                        // Connect to GCS home position updates
                        if (qtBridge.gcsHomePositionChanged) {
                            qtBridge.gcsHomePositionChanged.connect(function(lat, lon) {
                                console.log('GCS home position update:', lat, lon);
                                updateGCSHomeMarker(lat, lon);
                            });
                        }
                        
                        // Connect to mission path updates
                        if (qtBridge.missionPathChanged) {
                            qtBridge.missionPathChanged.connect(function(waypoints) {
                                console.log('Mission path update:', waypoints);
                                updateMissionPath(waypoints);
                            });
                        }
                        
                        // Connect to polygon drawing signals
                        if (qtBridge.startPolygonDrawing) {
                            qtBridge.startPolygonDrawing.connect(function() {
                                console.log('Starting polygon drawing mode');
                                startPolygonDrawingMode();
                            });
                        }
                        
                        if (qtBridge.clearPolygon) {
                            qtBridge.clearPolygon.connect(function() {
                                console.log('Clearing all polygons');
                                clearPolygon();
                            });
                        }
                        
                        if (qtBridge.clearPolygonById) {
                            qtBridge.clearPolygonById.connect(function(polygonId) {
                                console.log('Clearing polygon by ID:', polygonId);
                                clearPolygonById(polygonId);
                            });
                        }
                        
                        // Connect to altitude update signal
                        if (qtBridge.updatePolygonAltitude) {
                            qtBridge.updatePolygonAltitude.connect(function(polygonId, altitude) {
                                console.log('Updating polygon', polygonId, 'altitude to', altitude, 'm');
                                updatePolygonAltitude(polygonId, altitude);
                            });
                        }
                        
                        // Signal that web map is ready
                        if (qtBridge.webMapReady) {
                            qtBridge.webMapReady();
                        }
                    } else {
                        console.error('Qt mapBridge object not found');
                    }
                });
            } catch (error) {
                console.error('Qt WebChannel initialization failed:', error);
                addTestUAVMarkers();
            }
        }

        // Create custom UAV icon with orientation and status
        function createUAVIcon(heading, mode, armed, uavId) {
            const color = getUAVColor(mode, armed);
            const size = 20; // Triangle height
            const triangleWidth = size * 0.6; // Make triangle narrower (60% of height)
            const labelDistance = 12; // Distance from triangle to label (increased from 8)
            
            // Create simple triangle UAV icon with modern styling
            const html = `
                <div style="
                    width: 0; 
                    height: 0; 
                    border-left: ${triangleWidth/2}px solid transparent; 
                    border-right: ${triangleWidth/2}px solid transparent; 
                    border-bottom: ${size}px solid ${color};
                    transform: rotate(${heading}deg);
                    filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
                    position: relative;
                ">
                    <div style="
                        position: absolute;
                        top: ${size + labelDistance}px;
                        left: 50%;
                        transform: translateX(-50%) rotate(-${heading}deg);
                        background: rgba(0,0,0,0.5);
                        color: white;
                        padding: 1px 6px;
                        border-radius: 4px;
                        font-size: 9px;
                        font-weight: 500;
                        white-space: nowrap;
                        text-align: center;
                        min-width: max-content;
                        backdrop-filter: blur(2px);
                        border: 1px solid rgba(255,255,255,0.1);
                    ">${uavId}</div>
                </div>
            `;
            
            return L.divIcon({
                html: html,
                className: 'uav-marker',
                iconSize: [triangleWidth, size],
                iconAnchor: [triangleWidth/2, size]
            });
        }

        // Get UAV color based on mode and armed state
        function getUAVColor(mode, armed) {
            // Debug logging (commented to reduce log spam)
            // console.log('getUAVColor called - mode:', mode, 'armed:', armed);
            
            if (!armed) {
                // console.log('  -> Returning gray (disarmed)');  // Commented to reduce log spam
                return '#808080'; // Gray for disarmed
            }
            
            // Normalize mode to uppercase for case-insensitive matching
            const normalizedMode = mode ? mode.toUpperCase() : 'UNKNOWN';
            let color;
            
            switch(normalizedMode) {
                case 'STABILIZE': 
                    color = '#6600cc';  // Purple
                    break;
                case 'AUTO': 
                    color = '#00cc00';  // Green
                    break;
                case 'GUIDED': 
                    color = '#0066cc';  // Blue
                    break;
                case 'RTL': 
                    color = '#ffcc00';  // Yellow
                    break;
                case 'LAND': 
                    color = '#cc0000';  // Red
                    break;
                case 'LOITER': 
                    color = '#0066cc';  // Blue
                    break;
                case 'BRAKE': 
                    color = '#0066cc';  // Blue
                    break;
                default: 
                    color = '#ffffff';  // White for unknown
                    console.warn('  -> Unknown mode:', normalizedMode, '- using white');  // Keep warnings
                    break;
            }
            
            // console.log('  -> Mode:', normalizedMode, 'Color:', color);  // Commented to reduce log spam
            return color;
        }

        // Update or create UAV marker
        function updateUAVMarker(uavId, lat, lon, heading, mode, armed) {
            // console.log('updateUAVMarker called for', uavId, '- mode:', mode, 'armed:', armed, 'heading:', heading);  // Commented to reduce log spam
            
            if (!map) {
                console.warn('Map not initialized yet');
                return;
            }
            
            // Remove existing marker if it exists
            if (uavMarkers[uavId]) {
                // console.log('  -> Removing old marker for', uavId);  // Commented to reduce log spam
                map.removeLayer(uavMarkers[uavId]);
            }
            
            // Create new marker with current data
            // console.log('  -> Creating new marker for', uavId);  // Commented to reduce log spam
            const icon = createUAVIcon(heading, mode, armed, uavId);
            const marker = L.marker([lat, lon], {icon: icon});
            
            // Create popup with UAV information
            const popupContent = `
                <div style="font-family: Arial, sans-serif;">
                    <h4 style="margin: 0 0 8px 0; color: #333;">${uavId}</h4>
                    <div><strong>Mode:</strong> ${mode}</div>
                    <div><strong>Armed:</strong> ${armed ? 'Yes' : 'No'}</div>
                    <div><strong>Heading:</strong> ${heading.toFixed(1)}¬∞</div>
                    <div><strong>Position:</strong> ${lat.toFixed(6)}, ${lon.toFixed(6)}</div>
                </div>
            `;
            
            marker.bindPopup(popupContent);
            
            // Add click handler for UAV selection
            marker.on('click', function() {
                // console.log('UAV clicked:', uavId);  // Keep this one for debugging user interactions
                if (qtBridge && qtBridge.uavSelected) {
                    qtBridge.uavSelected(uavId);
                }
            });
            
            // Add to map and store reference
            marker.addTo(map);
            uavMarkers[uavId] = marker;
            
            // console.log('UAV marker updated:', uavId, 'at', lat, lon);  // Commented to reduce log spam
        }

        // Update home marker
        let homeMarker = null;
        function updateHomeMarker(lat, lon) {
            if (!map) return;
            
            if (homeMarker) {
                map.removeLayer(homeMarker);
            }
            
            const homeIcon = L.divIcon({
                html: `
                    <div style="
                        width: 10px; 
                        height: 10px; 
                        background: #00cc00; 
                        border: 2px solid white; 
                        border-radius: 50%;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                    "></div>
                `,
                className: 'home-marker',
                iconSize: [10, 10],
                iconAnchor: [5, 5]
            });
            
            homeMarker = L.marker([lat, lon], {icon: homeIcon});
            homeMarker.bindPopup('<strong>Home Position</strong><br/>Launch/Return point');
            homeMarker.addTo(map);
        }

        // Launch location markers for each UAV
        let launchMarkers = {};
        function updateLaunchLocationMarker(uavId, lat, lon) {
            if (!map) return;
            
            // Remove existing launch marker if it exists
            if (launchMarkers[uavId]) {
                map.removeLayer(launchMarkers[uavId]);
            }
            
            // Extract UAV number (e.g., "UAV_3" -> "3")
            const uavNumber = uavId.replace('UAV_', '');
            const labelText = 'L' + uavNumber;
            
            // Create launch location icon with label
            const launchIcon = L.divIcon({
                html: `
                    <div style="
                        width: 14px; 
                        height: 14px; 
                        background: rgba(255, 165, 0, 0.3); 
                        border: 2px solid #ff8800; 
                        border-radius: 50%;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <span style="
                            color: #ff8800;
                            font-weight: bold;
                            font-size: 9px;
                            font-family: Arial, sans-serif;
                        ">${labelText}</span>
                    </div>
                `,
                className: 'launch-marker',
                iconSize: [14, 14],
                iconAnchor: [7, 7]
            });
            
            const marker = L.marker([lat, lon], {icon: launchIcon});
            marker.bindPopup(`<strong>${uavId} Launch Location</strong><br/>Position: ${lat.toFixed(6)}, ${lon.toFixed(6)}`);
            marker.addTo(map);
            launchMarkers[uavId] = marker;
            
            console.log('Launch location marker updated:', uavId, 'at', lat, lon);
        }

        // Update mission path
        let missionPath = null;
        function updateMissionPath(waypoints) {
            if (!map) return;
            
            if (missionPath) {
                map.removeLayer(missionPath);
            }
            
            if (waypoints && waypoints.length > 0) {
                const latlngs = waypoints.map(wp => [wp.lat, wp.lon]);
                missionPath = L.polyline(latlngs, {
                    color: '#ff0000',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '10, 5'
                });
                missionPath.addTo(map);
            }
        }

        // Start polygon drawing mode
        function startPolygonDrawingMode(polygonId) {
            console.log('Activating polygon drawing mode for ID:', polygonId);
            polygonDrawing = true;
            currentPolygonId = polygonId;
            polygonPoints = [];
            clearPolygonMarkers();
            
            // Change cursor to crosshair
            map.getContainer().style.cursor = 'crosshair';
            
            // Show instruction
            L.popup()
                .setLatLng(map.getCenter())
                .setContent('<b>Polygon Drawing Mode</b><br/>Click to add points<br/>Right-click or click first point to close')
                .openOn(map);
                
            // Close popup after 3 seconds
            setTimeout(() => {
                map.closePopup();
            }, 3000);
        }

        // Clear polygon markers and lines
        function clearPolygonMarkers() {
            polygonMarkers.forEach(marker => map.removeLayer(marker));
            polygonMarkers = [];
            polygonLines.forEach(line => map.removeLayer(line));
            polygonLines = [];
            if (tempLine) {
                map.removeLayer(tempLine);
                tempLine = null;
            }
        }

        // Clear all polygons
        function clearPolygon() {
            console.log('Clearing all polygons');
            polygonDrawing = false;
            currentPolygonId = null;
            polygonPoints = [];
            clearPolygonMarkers();
            
            // Remove all drawn polygons
            Object.keys(drawnPolygons).forEach(id => {
                if (drawnPolygons[id]) {
                    map.removeLayer(drawnPolygons[id]);
                }
            });
            drawnPolygons = {};
            
            // Reset cursor
            map.getContainer().style.cursor = '';
        }
        
        // Clear specific polygon by ID
        function clearPolygonById(polygonId) {
            console.log('Clearing polygon with ID:', polygonId);
            
            if (drawnPolygons[polygonId]) {
                map.removeLayer(drawnPolygons[polygonId]);
                delete drawnPolygons[polygonId];
                console.log('Removed polygon', polygonId, 'from map');
            } else {
                console.log('Polygon', polygonId, 'not found on map');
            }
        }

        // Add point to polygon
        function addPolygonPoint(lat, lon) {
            const point = {lat: lat, lon: lon};
            
            // Check if clicking first point to close polygon
            if (polygonPoints.length >= 3) {
                const firstPoint = polygonPoints[0];
                const distance = Math.sqrt(
                    Math.pow(lat - firstPoint.lat, 2) + 
                    Math.pow(lon - firstPoint.lon, 2)
                );
                
                // If close to first point (within ~50 meters at this scale), close polygon
                if (distance < 0.0005) {
                    completePolygon();
                    return;
                }
            }
            
            polygonPoints.push(point);
            
            // Add marker for this point
            const marker = L.circleMarker([lat, lon], {
                radius: 6,
                fillColor: '#2196F3',
                color: '#ffffff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            });
            marker.bindPopup(`Point ${polygonPoints.length}<br/>${lat.toFixed(6)}, ${lon.toFixed(6)}`);
            marker.addTo(map);
            polygonMarkers.push(marker);
            
            // Draw line from previous point
            if (polygonPoints.length > 1) {
                const prevPoint = polygonPoints[polygonPoints.length - 2];
                const line = L.polyline(
                    [[prevPoint.lat, prevPoint.lon], [lat, lon]],
                    {
                        color: '#2196F3',
                        weight: 2,
                        opacity: 0.7,
                        dashArray: '5, 5'
                    }
                );
                line.addTo(map);
                polygonLines.push(line);
            }
            
            console.log('Added polygon point:', polygonPoints.length, 'at', lat, lon);
        }

        // Complete polygon drawing
        function completePolygon() {
            if (polygonPoints.length < 3) {
                console.log('Need at least 3 points to complete polygon');
                return;
            }
            
            console.log('Completing polygon with', polygonPoints.length, 'points, ID:', currentPolygonId);
            
            // Remove temporary markers and lines
            clearPolygonMarkers();
            
            // Draw final polygon with editing enabled
            const latlngs = polygonPoints.map(p => [p.lat, p.lon]);
            const polygon = L.polygon(latlngs, {
                color: '#2196F3',
                weight: 2,
                opacity: 0.8,
                fillColor: '#2196F3',
                fillOpacity: 0.2,
                pmIgnore: false  // Enable editing
            });
            polygon.addTo(map);
            
            // Store the polygon ID with the polygon object for later reference
            polygon.polygonId = currentPolygonId;
            
            // Enable editing on the polygon
            polygon.pm.enable({
                allowSelfIntersection: false,
                preventMarkerRemoval: false,
                draggable: true,
                snappable: true,
                snapDistance: 20
            });
            
            // Add event listeners for polygon editing
            polygon.on('pm:edit', function(e) {
                console.log('Polygon edited:', polygon.polygonId);
                updatePolygonAfterEdit(polygon, polygon.polygonId);
            });
            
            polygon.on('pm:vertexadded', function(e) {
                console.log('Vertex added to polygon:', polygon.polygonId);
                updatePolygonAfterEdit(polygon, polygon.polygonId);
            });
            
            polygon.on('pm:vertexremoved', function(e) {
                console.log('Vertex removed from polygon:', polygon.polygonId);
                updatePolygonAfterEdit(polygon, polygon.polygonId);
            });
            
            // Store polygon by ID
            if (currentPolygonId !== null) {
                drawnPolygons[currentPolygonId] = polygon;
                // Initialize altitude to default (will be updated from flight planning)
                polygonAltitudes[currentPolygonId] = 50; // Default altitude
            }
            
            // Set initial popup (will be updated when altitude is set)
            updatePolygonPopup(polygon, currentPolygonId);
            
            // Exit drawing mode
            polygonDrawing = false;
            map.getContainer().style.cursor = '';
            
            // Send polygon back to QML with ID
            if (qtBridge && qtBridge.polygonCompleted) {
                qtBridge.polygonCompleted(polygonPoints);
            }
            
            console.log('Polygon', currentPolygonId, 'completed and sent to QML');
            
            // Reset current polygon ID
            currentPolygonId = null;
        }
        
        // Update polygon information after editing
        function updatePolygonAfterEdit(polygon, polygonId) {
            const latlngs = polygon.getLatLngs()[0];
            
            // Update popup with area and GSD
            updatePolygonPopup(polygon, polygonId);
            
            // Convert back to the format expected by QML
            const points = latlngs.map(ll => ({
                lat: ll.lat,
                lon: ll.lng
            }));
            
            // Notify QML of the polygon update (if there's a handler)
            if (qtBridge && qtBridge.polygonUpdated) {
                qtBridge.polygonUpdated(polygonId, points);
            }
            
            const area = calculatePolygonArea(latlngs.map(ll => [ll.lat, ll.lng]));
            const areaKm2 = (area / 1000000).toFixed(3);
            console.log('Polygon', polygonId, 'updated with', points.length, 'points, area:', areaKm2, 'km¬≤');
        }
        
        // Calculate Ground Sampling Distance (GSD) in cm/pixel
        function calculateGSD(altitude) {
            // GSD = (2 * altitude * tan(HFOV/2)) / image_width
            // altitude in meters, HFOV in degrees
            const hfovRad = cameraConfig.hfov * (Math.PI / 180);
            const groundWidth = 2 * altitude * Math.tan(hfovRad / 2);
            const gsd = groundWidth / cameraConfig.image_width;
            return gsd * 100; // Convert from meters to centimeters
        }
        
        // Update polygon altitude and recalculate GSD
        function updatePolygonAltitude(polygonId, altitude) {
            polygonAltitudes[polygonId] = altitude;
            const polygon = drawnPolygons[polygonId];
            if (polygon) {
                updatePolygonPopup(polygon, polygonId);
            }
        }
        
        // Update polygon popup with area and GSD
        function updatePolygonPopup(polygon, polygonId) {
            const latlngs = polygon.getLatLngs()[0];
            const latlngArray = latlngs.map(ll => [ll.lat, ll.lng]);
            const area = calculatePolygonArea(latlngArray);
            const areaKm2 = (area / 1000000).toFixed(3);
            
            let popupContent = `<b>Polygon ${polygonId}</b><br/>Area: ${areaKm2} km¬≤<br/>Points: ${latlngs.length}`;
            
            // Add GSD if altitude is set
            if (polygonAltitudes[polygonId]) {
                const altitude = polygonAltitudes[polygonId];
                const gsd = calculateGSD(altitude);
                popupContent += `<br/>Altitude: ${altitude} m<br/>GSD: ${gsd.toFixed(2)} cm/pixel`;
            }
            
            // Check if popup already exists, if not bind it
            if (!polygon.getPopup()) {
                polygon.bindPopup(popupContent);
            } else {
                polygon.setPopupContent(popupContent);
            }
        }

        // Calculate polygon area in square meters (approximate)
        function calculatePolygonArea(latlngs) {
            if (latlngs.length < 3) return 0;
            
            // Convert to radians
            const toRad = Math.PI / 180;
            const R = 6371000; // Earth's radius in meters
            
            let area = 0;
            const n = latlngs.length;
            
            for (let i = 0; i < n; i++) {
                const p1 = latlngs[i];
                const p2 = latlngs[(i + 1) % n];
                
                const lat1 = p1[0] * toRad;
                const lat2 = p2[0] * toRad;
                const dLon = (p2[1] - p1[1]) * toRad;
                
                area += dLon * (2 + Math.sin(lat1) + Math.sin(lat2));
            }
            
            area = Math.abs(area * R * R / 2);
            return area;
        }

        // Add test UAV markers for demonstration
        function addTestUAVMarkers() {
            console.log('Adding test UAV markers');
            
            // Add some test UAVs at different locations
            updateUAVMarker('UAV_1', homePos.latitude + 0.001, homePos.longitude + 0.001, 45, 'STABILIZE', true);
            updateUAVMarker('UAV_2', homePos.latitude - 0.001, homePos.longitude + 0.002, 90, 'AUTO', true);
            updateUAVMarker('UAV_3', homePos.latitude + 0.002, homePos.longitude - 0.001, 180, 'RTL', false);
            
            // Add home marker
            updateHomeMarker(homePos.latitude, homePos.longitude);
        }
    </script>
</body>
</html>